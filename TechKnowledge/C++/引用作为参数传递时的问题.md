# 引用作为参数传递时的问题

## 临时变量的生成条件
当实参与引用参数不匹配时，C++会生成临时变量。**仅在参数为 const 引用时**，编译器会在以下两种情况下创建临时变量：
1. 实参类型正确，但**不是左值**
2. 实参类型不正确，但**可以转换为正确的类型**

---

## 为什么对 const 引用的限制是合理的？
### 示例：修改型函数（非 const 引用）
```cpp
void swapr(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

// 调用示例
long a = 3, b = 5;
swapr(a, b); // 类型不匹配！
```

- **旧版 C++行为**  
  生成临时 `int` 变量（值=3 和 5），交换临时变量内容，但原始变量 `a` 和 `b` 的值不变。
- **关键问题**  
  若函数意图是修改原始变量，临时变量会阻断这一行为。
- **现行 C++标准**  
  直接禁止为**非 const 引用**生成临时变量，从而避免逻辑错误。

---

### 示例：只读型函数（const 引用）
```cpp
void refcube(const int &x) { /* 仅读取 x 的值 */ }

// 允许以下调用
double y = 2.5;
refcube(y); // 生成临时 int 变量（值=2）
```
- **行为特性**  
  函数不修改原始数据时，临时变量：
  - 允许类型转换（如 `double → int`）
  - 使函数能处理更广泛的参数类型
- **实际效果**  
  此时函数行为与**按值传递**类似，原始数据受到保护。
